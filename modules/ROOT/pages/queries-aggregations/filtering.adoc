[[filtering]]
= Filtering
:page-aliases: filtering.adoc
:description: This page describes filtering operators.

When querying for data, a number of operators are available for different types in the `where` argument of a query or mutation.

== Equality operators

All types can be tested for either equality.
For non-equality, you *must* use the xref:/queries-aggregations/filtering.adoc#_combining_operators[`NOT`] logical operator.
For example:

.Filtering all Users named John
[source, graphql, indent=0]
----
query {
  users(where: { node: { name: { equals: "John" } } }) {
    connection {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
----

[NOTE]
====
For the `Boolean` type, equality operators are the only ones available.
====

== Numerical operators

These are the operators available for numeric (`Int`, `Float`, xref::/types/scalar.adoc[`BigInt`]), xref::/types/temporal.adoc[temporal] and xref::/types/spatial.adoc[spatial] types:

* `lt`
* `lte`
* `gt`
* `gte`

Here is an example of how to use them:

.Filtering Users younger than 50 years old
[source, graphql, indent=0]
----
query {
  users(where: { node: { age: { lt: 50 } } }) {
    connection {
      edges {
        node {
          id
          name
          age
        }
      }
    }
  }
}
----

== String comparison

The following case-sensitive comparison operators are only available for use on `String` and `ID` types:

* `startsWith`
* `endsWith`
* `contains`

Here is an example of how to use them:

.Filtering Users with name starting with "J"
[source, graphql, indent=0]
----
query {
  users(where: { node: { name: { startsWith: "J" } } }) {
    connection {
      edges {
        node {
         id
         name
        }
      }
    }
  }
}
----
== Relationship filtering

Filtering is done on the list of related nodes and is based on the https://neo4j.com/docs/cypher-manual/current/functions/predicate/[list predicates] available in Cypher:
** `all` - https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-all[all]
** `some` - https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-any[any]
** `none` - https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-none[none]
** `single` - https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-single[single]

As an example, take these type definitions:

[source, graphql, indent=0]
----
type User @node {
    id: ID!
    name: String
    posts: [Post!]! @relationship(type: "HAS_POST", direction: OUT)
}

type Post @node {
    id: ID!
    content: String
    likes: [User!]! @relationship(type: "LIKES", direction: IN)
    authors: [User!]! @relationship(type: "AUTHORED", direction: IN)
}
----

.Find all Users where all of their posts contain search term: `"neo4j"`
[source, graphql, indent=0]
----
query {
  users(where: { node: { posts: { all: { content: { contains: "neo4j" } } } } }) {
    connection {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
----

.Find all Users where none of their posts contains search term: `"cypher"`
[source, graphql, indent=0]
----
query {
  users(where: { node: { posts: { none: { content: { contains: "cypher" } } } } }) {
    connection {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
----

.Find all users where some of their posts contain search term: `"graphql"`
[source, graphql, indent=0]
----
query {
  users(where: { node: { posts: { some: { content: { contains: "graphql" } } } } }) {
    connection {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
----

.Find all users where only one of their posts contain search term: `"graph"`
[source, graphql, indent=0]
----
query {
  users(where: { node: { posts: { single: { content: { contains: "graph" } } } } }) {
    connection {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
----

