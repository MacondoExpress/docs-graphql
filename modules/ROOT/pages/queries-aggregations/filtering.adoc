[[filtering]]
= Filtering
:page-aliases: filtering.adoc
:description: This page describes filtering operators.

When querying for data, a number of operators are available for different types in the `where` argument of a query or mutation.

== Equality operators

All types can be tested for either equality.
For non-equality, you *must* use the xref:/queries-aggregations/filtering.adoc#_combining_operators[`NOT`] logical operator.
For example:

.Filtering all Users named John
[source, graphql, indent=0]
----
query {
  users(where: { node: { name: { equals: "John" } } }) {
    connection {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
----

[NOTE]
====
For the `Boolean` type, equality operators are the only ones available.
====

== Numerical operators

These are the operators available for numeric (`Int`, `Float`, xref::/types/scalar.adoc[`BigInt`]), xref::/types/temporal.adoc[temporal] and xref::/types/spatial.adoc[spatial] types:

* `lt`
* `lte`
* `gt`
* `gte`

Here is an example of how to use them:

.Filtering Users younger than 50 years old
[source, graphql, indent=0]
----
query {
  users(where: { node: { age: { lt: 50 } } }) {
    connection {
      edges {
        node {
          id
          name
          age
        }
      }
    }
  }
}
----

== String comparison

The following case-sensitive comparison operators are only available for use on `String` and `ID` types:

* `startsWith`
* `endsWith`
* `contains`

Here is an example of how to use them:

.Filtering Users with name starting with "J"
[source, graphql, indent=0]
----
query {
  users(where: { node: { name: { startsWith: "J" } } }) {
    connection {
      edges {
        node {
         id
         name
        }
      }
    }
  }
}
----

== Relationship filtering

Filtering is done on the list of related nodes and is based on the https://neo4j.com/docs/cypher-manual/current/functions/predicate/[list predicates] available in Cypher:
** `all` - https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-all[all]
** `some` - https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-any[any]
** `none` - https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-none[none]
** `single` - https://neo4j.com/docs/cypher-manual/current/functions/predicate/#functions-single[single]

As an example, take these type definitions:

[source, graphql, indent=0]
----
type User @node {
    id: ID!
    name: String
    posts: [Post!]! @relationship(type: "HAS_POST", direction: OUT, properties: "Posted")
}

type Post @node {
    id: ID!
    content: String
    likes: [User!]! @relationship(type: "LIKES", direction: IN)
    authors: [User!]! @relationship(type: "AUTHORED", direction: IN)
}

type Posted @relationshipProperties {
    createdAt: DateTime
}
----

.Find all Users where all of their posts contain search term: `"neo4j"`
[source, graphql, indent=0]
----
query {
  users(where: { node: { posts: { edges: { all: { node: { content: { contains: "neo4j" } } } } } } }) {
    connection {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
----

.Find all Users where none of their posts contains search term: `"cypher"`
[source, graphql, indent=0]
----
query {
  users(where: { node: { posts: { edges: { none: { node: { content: { contains: "cypher" } } } } } } }) {
    connection {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
----

.Find all users where some of their posts contain search term: `"graphql"`
[source, graphql, indent=0]
----
query {
  users(where: { node: { posts: { edges: { some: { node: { content: { contains: "graphql" } } } } } } }) {
    connection {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
----

.Find all users where only one of their posts contain search term: `"graph"`
[source, graphql, indent=0]
----
query {
  users(where: { node: { posts: { edges: { single: { node: { content: { contains: "graph" } } } } } } }) {
    connection {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
----

.Find all users where only one of their posts contain search term: `"graph"` and the post was created after a specific date
[source, graphql, indent=0]
----
query {
  users(where: { node: { posts: { edges: { single: { AND: [ { node: { content: { contains: "graph" } }  }, { properties: { createdAt: { gt: "2015-06-24T12:50:35" } }  } ]} } } } }) {
    connection {
      edges {
        node {
          id
          name
        }
      }
    }
  }
}
----

== Logical operators

All operators can be combined using the logical operators `AND`, `OR`, and `NOT`.
They can also be standalone operators, which means that they can be used as such and not be appended to field names.

These operators accept an array argument with items of the same format as the `where` argument, which means they can also be nested to form complex combinations.

For example, if you want to match all actors by the name of either "Keanu" or not belonging to the "Pantoliano" family, that played in "The Matrix" movie, here is how you can query that:

[source, graphql, indent=0]
----
query {
  actors(
    where: {
      node: {
        AND: [
          {
            OR: [
              { name: { contains: "Keanu" } }
              { name: { NOT: { endsWith: "Pantoliano" } } }
            ]
          }
          {
            movies: {
              edges: { some: { node: { title: { equals: "The Matrix" } } } }
            }
          }
        ]
      }
    }
  ) {
    connection {
      edges {
        node {
          name
          movies {
            connection {
              edges {
                node {
                  title
                }
              }
            }
          }
        }
      }
    }
  }
}
----
