[[type-definitions-relationships]]
= Relationships
:page-aliases: type-definitions/relationships.adoc, type-definitions/types/relationships.adoc
:description: This page describes how to write type definitions for a simple connected model, inserting data through the schema, and then querying it.


Without relationships, your type definitions work rather as a collection of disconnected nodes, with little value.
Adding relationships into your data model gives your data the context that it needs to run complex queries across wide sections of your graph.

This page describes how to write type definitions for a simple connected model, inserting data through the schema, and then querying it.

== Type definitions

Take the following graph as an example in which a `Person` type has two different relationship types, which can connect it to a `Movie` type.

image::relationships.svg[title="Example graph"]

To create that graph using the Neo4j GraphQL Library, first you need to define the nodes and define the two distinct types in this model:

[source, graphql, indent=0]
----
type Person @node {
    name: String!
    born: Int!
}

type Movie @node {
    title: String!
    released: Int!
}
----

You can then connect these two types together using `@relationship` directives:

[source, graphql, indent=0]
----
type Person @node {
    name: String!
    born: Int!
    actedInMovies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
    directedMovies: [Movie!]! @relationship(type: "DIRECTED", direction: OUT)
}

type Movie @node {
    title: String!
    released: Int!
    actors: [Person!]! @relationship(type: "ACTED_IN", direction: IN)
    directors: [Person!]! @relationship(type: "DIRECTED", direction: IN)
}
----

Note that, in this query:

* A `Person` can _act in_ or _direct_ multiple movies, and a `Movie` can have multiple actors. 
* To figure out whether the `direction` argument of the `@relationship` directive should be `IN` or `OUT`, visualize your relationships like in the diagram above, then model out the direction of the arrows.
* The `@relationship` directive is a reference to Neo4j relationships, whereas in the schema, the phrase `edge(s)` is used to be consistent with the general API language used by Relay.

=== Relationship properties

You can add relationship properties to the example in two steps:

. Add a type definition decorated with the `@relationshipProperties` directive, containing the desired relationship properties.
. Add a `properties` argument to both "sides" (or just one side, if you prefer) of the `@relationship` directive which points to the newly defined type.

For example, suppose you want to distinguish which roles an actor played in a movie:

[source, graphql, indent=0]
----
type Person @node {
    name: String!
    born: Int!
    actedInMovies: [Movie!]! @relationship(type: "ACTED_IN", properties: "ActedIn", direction: OUT)
    directedMovies: [Movie!]! @relationship(type: "DIRECTED", direction: OUT)
}

type Movie @node {
    title: String!
    released: Int!
    actors: [Person!]! @relationship(type: "ACTED_IN", properties: "ActedIn", direction: IN)
    directors: [Person!]! @relationship(type: "DIRECTED", direction: IN)
}

type ActedIn @relationshipProperties {
    roles: [String!]
}
----

== Fetching your data

Now that you have the `Movie` information in your database, you can query everything altogether as follows:

[source, graphql, indent=0]
----
query {
  movies(where: { node: { title: { equals: "Forrest Gump" } } }) {
    connection {
      edges {
        node {
          title
          released
          directors {
            connection {
              edges {
                edges {
                  node {
                    name
                    born
                  }
                }
              }
            }
          }
          actors {
            connection {
              edges {
                properties {
                  roles
                }
                node {
                  name
                  born
                }
              }
            }
          }
        }
      }
    }
  }
}
----

== Cardinality

Neo4j does not support cardinality enforcement, therefore to define a new relationship, it is mandatory to define the `@relationship` target as a required list of not nullable nodes.
For example:

[source, graphql, indent=0]
----
type User @node {
    name: String!
    posts: [Post!]! @relationship(type: "HAS_POST", direction: OUT)
}

type Post @node {
    name: String!
}
----

The relationship at `User.posts` is considered a "many" relationship, which means it should always be of type `NonNullListType` and `NonNullNamedType`. 
In other words, both the array and the type inside of a "many" relationship should have a `!`.
